# -*- coding: utf-8 -*-
"""
SonarCylinder.FCMacro
=====================
Generates a hollow rolling cylinder (tube) as an A/B test sonar target for the
ball-beam system (HC-SR04 measures along the beam).

COORDINATE CONVENTION (matches beam assembly orientation):
  X  = along beam (position axis; HC-SR04 measures along +X in this build)
  Y  = cylinder spin axis (across beam)
  Z  = vertical (up)

REFLECTION NOTE (HC-SR04):
  Compared to a sphere, a cylinder presents a longer strip of near-normal surface
  to an along-beam ultrasonic wave, often producing a stronger and more stable
  return.
  If you choose CYL_PROFILE="faceted", the many-sided polygon approximates planar
  patches that can further stabilize the echo. With high facet counts (>= 24),
  the "polygon wheel" rolling error is small.

Model origin:
- The macro creates the part centered at (0, 0, 0).
- When placed on a flat surface, the contact plane is at Z = −R_ROLL:
  - R_ROLL = CYL_RADIUS for CYL_PROFILE="cylinder"
  - R_ROLL ≈ CYL_RADIUS for CYL_PROFILE="faceted" (CYL_RADIUS is the inradius)
"""

import FreeCAD as App
import FreeCADGui as Gui
import Part
import math

# ═══════════════════════════════════════════════════════════════════════════════
#  PARAMETERS  —  adjust to your hardware before running
# ═══════════════════════════════════════════════════════════════════════════════

# ── Sonar convention ───────────────────────────────────────────────────────────
SONAR_AXIS       = "X"    # documented convention: HC-SR04 measures along +X (along beam)

# ── Beam geometry (used for default cylinder length) ───────────────────────────
BEAM_WIDTH_MM    = 30.0   # runner width [mm] (axis Y in the model)

# ── Hollowing / weight ─────────────────────────────────────────────────────────
HOLLOW_ENABLE    = True
SHELL_THICKNESS  = 1.2    # wall thickness [mm] (FDM typical: 1.2..2.0)

# ── Cylinder target (axis along +Y) ────────────────────────────────────────────
CYL_RADIUS       = 25.0   # radius [mm]
                           #   for CYL_PROFILE="faceted", this is the facet-to-center radius (inradius)
CYL_LENGTH_Y     = None   # None -> (BEAM_WIDTH_MM - CYL_CLEARANCE_MM)
CYL_CLEARANCE_MM = 0.6    # side clearance vs BEAM_WIDTH_MM [mm]
CYL_PROFILE      = "faceted"  # "faceted" (better echo) or "cylinder" (smoothest rolling)
CYL_FACETS       = 48     # even, >= 24 recommended
CYL_FACET_PHASE_DEG = (-180.0 / float(CYL_FACETS)) if CYL_FACETS else 0.0
                           # rotate polygon so a face normal aligns with +X
CYL_END_CAP_T    = 0.0    # [mm] end wall thickness along Y (0 = open tube)

# ── Optional features ──────────────────────────────────────────────────────────
CENTER_BORE_D    = 0.0    # through-bore diameter for axle/shaft [mm]; 0 = none

# ═══════════════════════════════════════════════════════════════════════════════
#  HELPERS
# ═══════════════════════════════════════════════════════════════════════════════
Y_AXIS = App.Vector(0, 1, 0)


def cyl_y(radius, height, y_start):
    """Solid cylinder with axis along +Y, base circle centred at (0, y_start, 0)."""
    return Part.makeCylinder(float(radius), float(height), App.Vector(0, float(y_start), 0), Y_AXIS)


def prism_y(circumradius, height, y_start, n_sides, phase_rad):
    """Regular N-gon prism with axis along +Y, defined by circumradius in the XZ plane."""
    pts = []
    for i in range(int(n_sides)):
        theta = float(phase_rad) + (2.0 * math.pi * float(i) / float(n_sides))
        pts.append(
            App.Vector(
                float(circumradius) * math.cos(theta),
                float(y_start),
                float(circumradius) * math.sin(theta),
            )
        )
    pts.append(pts[0])  # close
    wire = Part.makePolygon(pts)
    face = Part.Face(wire)
    return face.extrude(App.Vector(0, float(height), 0))


def _sanitize_facets(name, facets, phase_deg, default_phase_deg):
    """Return (facets_even_int, phase_deg_float) with warnings."""
    facets_i = int(facets)
    phase_f = float(phase_deg)
    is_default = abs(phase_f - float(default_phase_deg)) < 1e-9
    if facets_i < 3:
        App.Console.PrintWarning(f"SonarCylinder: {name} < 3 invalid; clamping to 3.\n")
        facets_i = 3
    if (facets_i % 2) != 0:
        App.Console.PrintWarning(f"SonarCylinder: {name}={facets_i} is odd; bumping to {facets_i + 1}.\n")
        facets_i += 1
        if is_default:
            phase_f = -180.0 / float(facets_i)
    if facets_i < 12:
        App.Console.PrintWarning(f"SonarCylinder: {name}={facets_i} is low; echo may be intermittent.\n")
    elif facets_i < 24:
        App.Console.PrintWarning(f"SonarCylinder: {name}={facets_i} is OK, but >=24 is recommended.\n")
    return facets_i, phase_f


def _circumradius_from_inradius(inradius, n_sides):
    return float(inradius) / math.cos(math.pi / float(n_sides))


def build_cylinder():
    # Determine length along Y.
    if CYL_LENGTH_Y is None:
        length_y = float(BEAM_WIDTH_MM) - float(CYL_CLEARANCE_MM)
        length_y = max(1.0, length_y)
    else:
        length_y = max(1.0, float(CYL_LENGTH_Y))

    half_l = 0.5 * length_y

    # Profile selection.
    cyl_profile = str(CYL_PROFILE).strip().lower()
    if cyl_profile not in ("cylinder", "faceted"):
        App.Console.PrintWarning(
            f"SonarCylinder: CYL_PROFILE={CYL_PROFILE!r} not recognized; using 'faceted'.\n"
        )
        cyl_profile = "faceted"

    # Outer body.
    if cyl_profile == "faceted":
        cyl_facets, cyl_phase_deg = _sanitize_facets(
            "CYL_FACETS", CYL_FACETS, CYL_FACET_PHASE_DEG,
            (-180.0 / float(CYL_FACETS)) if CYL_FACETS else 0.0
        )
        cyl_phase_rad = math.radians(float(cyl_phase_deg))
        outer_circum = _circumradius_from_inradius(CYL_RADIUS, cyl_facets)
        outer = prism_y(outer_circum, length_y, -half_l, cyl_facets, cyl_phase_rad)
        r_roll = float(CYL_RADIUS)
        r_max = float(outer_circum)
        facets = int(cyl_facets)
        phase_deg_out = float(cyl_phase_deg)
    else:
        cyl_phase_rad = 0.0
        outer = cyl_y(CYL_RADIUS, length_y, -half_l)
        r_roll = float(CYL_RADIUS)
        r_max = float(CYL_RADIUS)
        facets = 0
        phase_deg_out = 0.0

    shape = outer

    # Hollowing: subtract an inner body, leaving open ends or end caps.
    if HOLLOW_ENABLE and float(SHELL_THICKNESS) > 0:
        t = float(SHELL_THICKNESS)
        if float(CYL_RADIUS) <= t:
            App.Console.PrintWarning("SonarCylinder: SHELL_THICKNESS too large; hollow skipped.\n")
        else:
            inner_r = float(CYL_RADIUS) - t
            end_cap_t = max(0.0, float(CYL_END_CAP_T))
            inner_len = max(0.0, length_y - 2.0 * end_cap_t)
            if inner_len > 0.0:
                inner_y0 = -half_l + end_cap_t
                if cyl_profile == "faceted":
                    inner_circum = _circumradius_from_inradius(inner_r, int(facets))
                    inner = prism_y(inner_circum, inner_len, inner_y0, int(facets), cyl_phase_rad)
                else:
                    inner = cyl_y(inner_r, inner_len, inner_y0)
                shape = outer.cut(inner)

    # Optional center bore (cuts through everything).
    if float(CENTER_BORE_D) > 0:
        bore = cyl_y(0.5 * float(CENTER_BORE_D), length_y, -half_l)
        shape = shape.cut(bore)

    meta = dict(
        geometry="cylinder",
        cyl_profile=cyl_profile,
        cyl_facets=int(facets),
        cyl_phase_deg=float(phase_deg_out),
        r_roll=float(r_roll),
        r_max=float(r_max),
        length_y=float(length_y),
        end_cap_t=float(CYL_END_CAP_T) if HOLLOW_ENABLE else 0.0,
    )
    return shape.removeSplitter(), meta


# ═══════════════════════════════════════════════════════════════════════════════
#  BUILD + ADD TO FREECAD DOCUMENT
# ═══════════════════════════════════════════════════════════════════════════════

shape, meta = build_cylinder()
obj_name = "SonarTarget_Cylinder"

doc = App.activeDocument()
if doc is None:
    doc = App.newDocument("SonarCylinder")

feature = doc.getObject(obj_name)
if feature is None:
    feature = doc.addObject("Part::Feature", obj_name)
feature.Shape = shape

try:
    Gui.ActiveDocument.getObject(obj_name).ShapeColor = (0.8, 0.8, 0.8)
except Exception:
    pass

doc.recompute()
try:
    Gui.SendMsgToActiveView("ViewFit")
    Gui.activeDocument().activeView().viewIsometric()
except Exception:
    pass

# ═══════════════════════════════════════════════════════════════════════════════
#  CONSOLE SUMMARY
# ═══════════════════════════════════════════════════════════════════════════════
vol_mm3 = shape.Volume
vol_cm3 = vol_mm3 / 1000.0
mass_solid = vol_cm3 * 1.24     # PLA density g/cm³
mass_20pct = mass_solid * 0.24  # rough 20% infill + perimeter walls

facets = int(meta.get("cyl_facets", 0)) if meta.get("cyl_profile") == "faceted" else 0
max_face_normal_error_deg = (180.0 / float(facets)) if facets > 0 else 0.0
reflected_ray_deviation_deg = 2.0 * max_face_normal_error_deg if facets > 0 else 0.0

App.Console.PrintMessage(
    "\n┌── Sonar Cylinder Target ────────────────────────────────────┐\n"
    f"│  Profile                     : {meta.get('cyl_profile', '?'):>8s}                 │\n"
    f"│  CYL_RADIUS (inradius)        : {meta.get('r_roll', 0.0):6.2f} mm              │\n"
    f"│  Max radius (vertex)          : {meta.get('r_max', 0.0):6.2f} mm              │\n"
    f"│  Length along Y               : {meta.get('length_y', 0.0):6.2f} mm              │\n"
    f"│  Shell thickness              : {(float(SHELL_THICKNESS) if HOLLOW_ENABLE else 0.0):6.2f} mm              │\n"
    f"│  End cap thickness (each)     : {(float(CYL_END_CAP_T) if HOLLOW_ENABLE else 0.0):6.2f} mm              │\n"
    f"│  Center bore diameter         : {float(CENTER_BORE_D):6.2f} mm              │\n"
    f"│  Volume (solid)               : {vol_cm3:6.1f} cm³              │\n"
    f"│  Mass: PLA solid              : {mass_solid:6.1f} g                │\n"
    f"│  Mass: PLA ~20% infill est.   : {mass_20pct:6.1f} g                │\n"
    "└────────────────────────────────────────────────────────────┘\n"
    f"\n  SONAR AXIS   = +{SONAR_AXIS} (along beam)\n"
    f"  FACETS       = {facets} (max normal error {max_face_normal_error_deg:.2f}°; deviation ~{reflected_ray_deviation_deg:.2f}°)\n"
    f"\n  PRINT TIP: keep the rolling surface support-free and clean.\n"
)

